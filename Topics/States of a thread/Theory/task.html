<h2>States of a thread</h2>
<div class="step-text">
<p>Throughout its lifecycle, a thread's state changes. This is caused by both the actions of the programmer and some internal events in the operating system. In this topic, we will consider the possible states of a thread presented both in Kotlin terms and on the operating system (OS) level.</p>
<h5 id="threadstate-enum">Thread.State enum</h5>
<p>In Kotlin, the state of a thread is defined by the <code class="language-kotlin">Thread.State</code> enum with six possible values:</p>
<ul><li><p><code class="language-kotlin">NEW</code>: an instance of the class <code class="language-kotlin">Thread</code> has been created, but it has not yet started;</p></li><li><p><code class="language-kotlin">RUNNABLE</code>: the thread is running in the JVM, but it may be waiting for some resources from the OS (e.g., from the processor);</p></li><li><p><code class="language-kotlin">BLOCKED</code>: the thread is blocked and waiting for a monitor lock (we will consider it later);</p></li><li><p><code class="language-kotlin">WAITING</code>: the thread is waiting for another thread to perform a task indefinitely long (e.g., <a class="theory-lookup not-relevant" href="/learn/step/20159" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, `join` is a function that allows you to wait for a coroutine to complete its execution. | It is often used when you want to launch multiple independent operations simultaneously and wait for their results later, cancel them, or do something else. Join is a powerful tool that provides more features than can be discussed in a single topic. It is used to bridge the gap between regular and suspending functions. Join can be used to check the validity of an expression or to join a sequence of relational operations in a single expression.">join</a> without timeout);</p></li><li><p><code class="language-kotlin">TIMED_WAITING</code>: the thread is waiting for another thread for a specified time (e.g., sleep, join with timeout);</p></li><li><p><code class="language-kotlin">TERMINATED</code>: the thread is terminated when the <code class="language-kotlin">run</code> function completes execution or an uncaught exception occurs. Once the thread terminates, it never gets back to its runnable state.</p></li></ul>
<p>To obtain the current state of a thread, we use the parameter <code class="language-kotlin">state</code>.</p>
<p>Let's look at how these states change depending on the programmer's actions.</p>
<pre><code class="language-kotlin">val worker: Thread = thread(start = false, block = {
    for (i in 1..10000)
        print("$i ")
    println("End of the work")
}) // new worker to make a difficult task
println(worker.state) // NEW

worker.start() // start the worker
println(worker.state) // RUNNABLE

worker.join()  // waiting for completing the worker
println(worker.state) // TERMINATED</code></pre>
<p>When a thread is created, its state is <code class="language-kotlin">NEW</code>. When a thread is started, its state is <code class="language-kotlin">RUNNABLE</code> (the function <code class="language-kotlin">run</code> may not be called yet). Finally, when a thread is completed, the state is <code class="language-kotlin">TERMINATED</code>. Besides, the <code class="language-kotlin">main</code> thread also goes through the state <code class="language-kotlin">WAITING</code> (indefinitely long) after invoking the <code class="language-kotlin">worker.join()</code> function.</p>
<h5 id="the-almost-real-lifecycle-of-a-thread">The (almost) real lifecycle of a thread</h5>
<p>The above states have been discussed in Kotlin terms. The real lifecycle of a thread is slightly different. For example, the <code class="language-kotlin">RUNNABLE</code> state is actually more complex than it might seem: in this state, a thread might actually be running or it might be <a class="theory-lookup not-relevant" href="/learn/step/20159" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a ready state in the context of threading refers to a thread that is prepared to start executing its task. | Once a thread is initialized, it transitions to the ready state, where it waits for the thread scheduler to allocate CPU time for it to run. This sharing of processor time between multiple threads concurrently prevents any single thread from consuming all the available processing power. It is important to note that a thread in the ready state is able to continue its execution only when it is moved to the running state by the thread scheduler.">ready</a> to run.</p>
<p>Below, you may see the simplified lifecycle of a thread in the OS terminology. The diagram includes five states and the events that cause the thread to jump from one state to another. Please do not confuse these states with the corresponding states in Kotlin (those are in UPPERCASE).</p>
<p style="text-align: center;"><picture><img alt="the simplified lifecycle of a thread in the OS terminology" height="105" src="https://ucarecdn.com/06e9a09a-7e0a-4d18-8bb7-cbe6bbd33f21/" width="300"/></picture></p>
<p><strong>The simplified lifecycle of a thread in the operating system</strong></p>
<p>After initialization, the thread is ready to run (<strong>Ready</strong>). It is the responsibility of the <strong>thread scheduler</strong> to give some instants of time for the thread to run (<strong>Running</strong>) and then move it again to <strong>Ready</strong>. This is used to share the processor time between <a class="theory-lookup not-relevant" href="/learn/step/20159" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a multiple thread refers to a program that contains two or more threads of execution. | Each thread represents a sequence of instructions that can be executed concurrently. A thread is represented by an object, specifically an instance of the Thread class or its subclass. The main thread, which runs the main function, is created automatically in every program. When you create and start one or more threads that will run in parallel with the main thread, the program becomes a multithreaded program.">multiple threads</a> concurrently: otherwise, one thread could consume all the available processor time.</p>
<p>The <strong>Waiting </strong>state means that a thread is temporarily inactive (for example, it may be waiting for another thread or for I/O to complete). A thread in this state cannot continue its execution any further until it is moved to the <strong>Ready</strong> state. Actually, the waiting state is a set of different states, which we will consider in the following topics.</p>
<p>Of course, the real lifecycle of threads is even more complex than we've outlined, but for now, it is enough to have at least a general understanding of how threads work.</p>
<h5 id="conclusion">Conclusion</h5>
<p>In this topic, we've learned what states threads can go through in their lifecycle. It's really important to know that in order to manage your threads' work. Now, to solidify your knowledge, let's move on to some practice.</p>
</div>
